// @ts-nocheck
import { Command } from '../../command/index'
import * as Cases from '../../schematics/correct'
import * as Validators from './compiled/index'

export function Execute(iterations: number) {
  const results = new Map<string, number>()
  Cases.Benchmark(Cases.Array_Number, iterations, results, () => Validators.Array_Number)
  Cases.Benchmark(Cases.Array_Object, iterations, results, () => Validators.Array_Object)
  Cases.Benchmark(Cases.Array_Recursive, iterations, results, () => Validators.Array_Recursive)
  Cases.Benchmark(Cases.Array_Union, iterations, results, () => Validators.Array_Union)
  Cases.Benchmark(Cases.Boolean_Boolean, iterations, results, () => Validators.Boolean_Boolean)
  Cases.Benchmark(Cases.Composite_Intersect, iterations, results, () => Validators.Composite_Intersect)
  Cases.Benchmark(Cases.Composite_Union_Discriminated, iterations, results, () => Validators.Composite_Union_Discriminated)
  Cases.Benchmark(Cases.Composite_Union_Non_Discriminated, iterations, results, () => Validators.Composite_Union_Non_Discriminated)
  Cases.Benchmark(Cases.Composite_Union_String_Literal, iterations, results, () => Validators.Composite_Union_String_Literal)
  Cases.Benchmark(Cases.Literal_Boolean, iterations, results, () => Validators.Literal_Boolean)
  Cases.Benchmark(Cases.Literal_Number, iterations, results, () => Validators.Literal_Number)
  Cases.Benchmark(Cases.Literal_String, iterations, results, () => Validators.Literal_String)
  Cases.Benchmark(Cases.Math_Matrix4, iterations, results, () => Validators.Math_Matrix4)
  Cases.Benchmark(Cases.Math_Mesh, iterations, results, () => Validators.Math_Mesh)
  Cases.Benchmark(Cases.Math_Transform3D, iterations, results, () => Validators.Math_Transform3D)
  Cases.Benchmark(Cases.Math_Vector3, iterations, results, () => Validators.Math_Vector3)
  Cases.Benchmark(Cases.Null_Null, iterations, results, () => Validators.Null_Null)
  Cases.Benchmark(Cases.Number_Exclusive_Maximum, iterations, results, () => Validators.Number_Exclusive_Maximum)
  Cases.Benchmark(Cases.Number_Exclusive_Minimum, iterations, results, () => Validators.Number_Exclusive_Minimum)
  Cases.Benchmark(Cases.Number_Integer, iterations, results, () => Validators.Number_Integer)
  Cases.Benchmark(Cases.Number_Maximum, iterations, results, () => Validators.Number_Maximum)
  Cases.Benchmark(Cases.Number_Minimum, iterations, results, () => Validators.Number_Minimum)
  Cases.Benchmark(Cases.Number_Multiple_Of, iterations, results, () => Validators.Number_Multiple_Of)
  Cases.Benchmark(Cases.Number_NaN, iterations, results, () => Validators.Number_NaN)
  Cases.Benchmark(Cases.Number_Number, iterations, results, () => Validators.Number_Number)
  Cases.Benchmark(Cases.Object_Additional_Properties_Boolean, iterations, results, () => Validators.Object_Additional_Properties_Boolean)
  Cases.Benchmark(Cases.Object_Additional_Properties_False, iterations, results, () => Validators.Object_Additional_Properties_False)
  Cases.Benchmark(Cases.Object_Additional_Properties_True, iterations, results, () => Validators.Object_Additional_Properties_True)
  Cases.Benchmark(Cases.Object_Object, iterations, results, () => Validators.Object_Object)
  Cases.Benchmark(Cases.Object_Partial, iterations, results, () => Validators.Object_Partial)
  Cases.Benchmark(Cases.Recursive_Node, iterations, results, () => Validators.Recursive_Node)
  Cases.Benchmark(Cases.Recursive_Union_Node, iterations, results, () => Validators.Recursive_Union_Node)
  Cases.Benchmark(Cases.String_MaxLength, iterations, results, () => Validators.String_MaxLength)
  Cases.Benchmark(Cases.String_MinLength, iterations, results, () => Validators.String_MinLength)
  Cases.Benchmark(Cases.String_Pattern, iterations, results, () => Validators.String_Pattern)
  Cases.Benchmark(Cases.String_String, iterations, results, () => Validators.String_String)
  Cases.Benchmark(Cases.Tuple_Number, iterations, results, () => Validators.Tuple_Number)
  Cases.Benchmark(Cases.Tuple_Object, iterations, results, () => Validators.Tuple_Object)
  Cases.Benchmark(Cases.Tuple_Union_String_Literal, iterations, results, () => Validators.Tuple_Union_String_Literal)
  Cases.Benchmark(Cases.Typia_Array_Hierarchical, iterations, results, () => Validators.Typia_Array_Hierarchical)
  Cases.Benchmark(Cases.Typia_Array_Recursive, iterations, results, () => Validators.Typia_Array_Recursive)
  Cases.Benchmark(Cases.Typia_Array_Recursive_Union_Explicit, iterations, results, () => Validators.Typia_Array_Recursive_Union_Explicit)
  Cases.Benchmark(Cases.Typia_Array_Recursive_Union_Implicit, iterations, results, () => Validators.Typia_Array_Recursive_Union_Implicit)
  Cases.Benchmark(Cases.Typia_Array_Simple, iterations, results, () => Validators.Typia_Array_Simple)
  Cases.Benchmark(Cases.Typia_Object_Hierarchical, iterations, results, () => Validators.Typia_Object_Hierarchical)
  Cases.Benchmark(Cases.Typia_Object_Recursive, iterations, results, () => Validators.Typia_Object_Recursive)
  Cases.Benchmark(Cases.Typia_Object_Union_Explicit, iterations, results, () => Validators.Typia_Object_Union_Explicit)
  Cases.Benchmark(Cases.Typia_Object_Union_Implicit, iterations, results, () => Validators.Typia_Object_Union_Implicit)
  return results
}

const parameter = Command.Parameter()
const results = Execute(parameter.iterations)
Command.WriteResults(results)